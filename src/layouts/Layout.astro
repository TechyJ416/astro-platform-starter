---
// src/layouts/Layout.astro
import { supabase } from "../lib/supabase";
import ImpersonationBanner from "../components/ImpersonationBanner.astro";

interface Props {
  title?: string;
  description?: string;
}

const { title, description } = Astro.props;

let general = {
  siteName: "Banity",
  tagline: "Create Authentic Content. Get Paid.",
  description: "Banity connects creators with brands for authentic UGC campaigns.",
};

let appearance = {
  primaryColor: "#4f8bff",
  accentColor: "#a855f7",
  logoUrl: "",
  faviconUrl: "",
};

try {
  const { data } = await supabase.from("site_settings").select("key, value");
  if (data) {
    for (const row of data) {
      if (row.key === "general") general = { ...general, ...row.value };
      if (row.key === "appearance") appearance = { ...appearance, ...row.value };
    }
  }
} catch (e) {}

const pageTitle = title ? `${title} | ${general.siteName}` : `${general.siteName} - ${general.tagline}`;
const pageDescription = description || general.description;

const session = Astro.locals?.session;
const isAdmin = Astro.locals?.isAdmin;
const isModerator = Astro.locals?.isModerator;
const isImpersonating = Astro.locals?.isImpersonating || false;
const impersonatedUser = Astro.locals?.impersonatedUser;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{pageTitle}</title>
    <meta name="description" content={pageDescription} />
    {appearance.faviconUrl ? (
      <link rel="icon" href={appearance.faviconUrl} />
    ) : (
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    )}
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  </head>

  <body class:list={[{ "has-impersonation-banner": isImpersonating }]}>
    <canvas id="bg-particles" aria-hidden="true"></canvas>

    {isImpersonating && impersonatedUser && (
      <ImpersonationBanner user={impersonatedUser} />
    )}

    <nav class="main-nav">
      <div class="nav-content">
        <a href="/" class="nav-logo">
          {appearance.logoUrl ? (
            <img src={appearance.logoUrl} alt={general.siteName} class="logo-img" />
          ) : (
            <>
              <span class="logo-icon">✦</span>
              <span class="logo-text">{general.siteName}</span>
            </>
          )}
        </a>
        <div class="nav-links">
          <a href="/campaigns">Campaigns</a>
          <a href="/creators">Creators</a>
          <a href="/community">Community</a>
          <a href="/contact">Contact</a>
        </div>
        <div class="nav-actions">
          {session ? (
            <>
              <a href="/dashboard" class="nav-link">Dashboard</a>
              {(isAdmin || isModerator) && !isImpersonating && (
                <a href="/admin" class="nav-link">Admin</a>
              )}
              {!isImpersonating && <a href="/logout" class="nav-link">Log Out</a>}
            </>
          ) : (
            <>
              <a href="/login" class="nav-link">Sign In</a>
              <a href="/signup" class="nav-btn">Join Now</a>
            </>
          )}
        </div>
      </div>
    </nav>

    <main class="main-content">
      <slot />
    </main>

    <footer class="main-footer">
      <div class="footer-inner">
        <div class="footer-brand">
          <span class="footer-logo">✦ {general.siteName}</span>
          <p>The premier platform for UGC creators</p>
        </div>
        <div class="footer-links">
          <a href="/campaigns">Campaigns</a>
          <a href="/community">Community</a>
          <a href="/contact">Contact</a>
        </div>
        <div class="footer-copy">© 2024 {general.siteName}. All rights reserved.</div>
      </div>
    </footer>

    <style is:global>
      :root {
        --void: #030108;
        --nebula: #0a0510;
        --stardust: #150a20;
        --surface: #1a1025;
        --surface-light: #251535;
        --cosmic-blue: #8b5cf6;
        --cosmic-purple: #c026d3;
        --cosmic-pink: #ec4899;
        --cosmic-magenta: #d946ef;
        --cosmic-cyan: #a78bfa;
        --star-white: #f8fafc;
        --star-dim: #a78bfa;
        --star-muted: #7c3aed;
        --glow-purple: rgba(192, 38, 211, 0.5);
        --glow-pink: rgba(236, 72, 153, 0.5);
        --glow-violet: rgba(139, 92, 246, 0.5);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --font-display: 'Syne', system-ui, sans-serif;
        --font-mono: 'Space Mono', monospace;
      }

      * { margin: 0; padding: 0; box-sizing: border-box; }
      html { scroll-behavior: smooth; }

      body {
        font-family: var(--font-display);
        background: var(--void);
        color: var(--star-white);
        line-height: 1.6;
        min-height: 100vh;
        overflow-x: hidden;
      }

      a { color: inherit; }

      #bg-particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
      }

      .main-nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        padding: 1rem 2rem;
        background: linear-gradient(180deg, rgba(3, 1, 8, 0.95) 0%, rgba(3, 1, 8, 0.7) 50%, transparent 100%);
        backdrop-filter: blur(12px);
      }

      .nav-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 2rem;
      }

      .nav-logo {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        text-decoration: none;
        color: var(--star-white);
      }

      .logo-img { height: 32px; width: auto; }

      .logo-icon {
        font-size: 1.5rem;
        color: var(--cosmic-purple);
        text-shadow: 0 0 20px var(--glow-purple);
        animation: logo-glow 3s ease-in-out infinite;
      }

      @keyframes logo-glow {
        0%, 100% { text-shadow: 0 0 20px var(--glow-purple); }
        50% { text-shadow: 0 0 30px var(--glow-purple), 0 0 50px var(--glow-pink); }
      }

      .logo-text {
        font-size: 1.25rem;
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      .nav-links {
        display: flex;
        align-items: center;
        gap: 2rem;
      }

      .nav-links a {
        color: rgba(255, 255, 255, 0.6);
        text-decoration: none;
        font-size: 0.9375rem;
        font-weight: 500;
        transition: color 0.3s;
      }

      .nav-links a:hover { color: var(--star-white); }

      .nav-actions {
        display: flex;
        align-items: center;
        gap: 1.5rem;
      }

      .nav-link {
        color: rgba(255, 255, 255, 0.6);
        text-decoration: none;
        font-size: 0.9375rem;
        font-weight: 500;
        transition: color 0.3s;
      }

      .nav-link:hover { color: var(--star-white); }

      .nav-btn {
        padding: 0.625rem 1.5rem;
        background: linear-gradient(135deg, var(--cosmic-purple), var(--cosmic-pink));
        border-radius: 100px;
        color: white !important;
        text-decoration: none;
        font-weight: 600;
        font-size: 0.875rem;
        transition: all 0.3s;
        box-shadow: 0 4px 20px rgba(192, 38, 211, 0.3);
      }

      .nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 30px rgba(192, 38, 211, 0.5);
      }

      .main-content {
        position: relative;
        z-index: 1;
        min-height: calc(100vh - 200px);
        padding-top: 80px;
      }

      .main-footer {
        position: relative;
        z-index: 1;
        padding: 3rem 2rem;
        border-top: 1px solid rgba(192, 38, 211, 0.1);
        background: linear-gradient(180deg, transparent, rgba(3, 1, 8, 0.9));
      }

      .footer-inner {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 2rem;
      }

      .footer-logo {
        font-size: 1.125rem;
        font-weight: 700;
        color: var(--star-white);
      }

      .footer-brand p {
        margin-top: 0.5rem;
        font-size: 0.875rem;
        color: rgba(255, 255, 255, 0.5);
      }

      .footer-links {
        display: flex;
        gap: 2rem;
      }

      .footer-links a {
        color: rgba(255, 255, 255, 0.5);
        text-decoration: none;
        font-size: 0.875rem;
        transition: color 0.3s;
      }

      .footer-links a:hover { color: var(--star-white); }

      .footer-copy {
        width: 100%;
        text-align: center;
        padding-top: 2rem;
        border-top: 1px solid rgba(192, 38, 211, 0.1);
        font-size: 0.8125rem;
        color: rgba(255, 255, 255, 0.4);
      }

      /* Global utility classes */
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1.5rem;
        border-radius: 12px;
        font-weight: 600;
        font-size: 0.9375rem;
        text-decoration: none;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
      }

      .btn-primary {
        background: linear-gradient(135deg, var(--cosmic-purple), var(--cosmic-pink));
        color: white;
        box-shadow: 0 4px 20px rgba(192, 38, 211, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 30px rgba(192, 38, 211, 0.5);
      }

      .btn-secondary {
        background: rgba(192, 38, 211, 0.15);
        color: var(--star-white);
        border: 1px solid rgba(192, 38, 211, 0.3);
      }

      .btn-secondary:hover {
        background: rgba(192, 38, 211, 0.25);
        border-color: var(--cosmic-purple);
      }

      .btn-disabled {
        background: var(--surface);
        color: var(--star-muted);
        cursor: not-allowed;
      }

      @media (max-width: 768px) {
        .nav-links { display: none; }
        .nav-actions { gap: 1rem; }
        .footer-inner { flex-direction: column; text-align: center; }
        .footer-links { justify-content: center; }
      }
    </style>

    <script is:inline>
      class CosmicNebula {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.time = 0;
          this.particles = [];
          this.ambientParticles = [];
          this.nebulaLayers = [];
          
          this.init();
          this.animate();
        }

        init() {
          this.resize();
          this.createNebula();
          this.createParticles();
          this.createAmbientParticles();
          
          window.addEventListener('resize', () => {
            this.resize();
            this.createNebula();
            this.createParticles();
            this.createAmbientParticles();
          });
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.centerX = this.canvas.width / 2;
        }

        createNebula() {
          this.nebulaLayers = [];
          
          const layerCount = 12;
          for (let i = 0; i < layerCount; i++) {
            const blobsInLayer = 3 + Math.floor(Math.random() * 3);
            for (let j = 0; j < blobsInLayer; j++) {
              const yOffset = (i / layerCount) * this.canvas.height * 1.5;
              this.nebulaLayers.push({
                x: this.centerX + (Math.random() - 0.5) * 300,
                y: yOffset - this.canvas.height * 0.25,
                baseY: yOffset - this.canvas.height * 0.25,
                width: Math.random() * 250 + 150,
                height: Math.random() * 300 + 200,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.002,
                color: this.getNebulaColor(),
                alpha: Math.random() * 0.15 + 0.08,
                speed: 0.3 + Math.random() * 0.2,
                wobbleAmp: Math.random() * 30 + 10,
                wobbleFreq: Math.random() * 0.01 + 0.005
              });
            }
          }
        }

        createParticles() {
          this.particles = [];
          const count = 3000;
          
          for (let i = 0; i < count; i++) {
            const gaussX = this.gaussianRandom() * 200;
            const x = this.centerX + gaussX;
            const y = Math.random() * this.canvas.height * 1.5 - this.canvas.height * 0.25;
            
            const distFromCenter = Math.abs(gaussX);
            const centralness = 1 - Math.min(distFromCenter / 300, 1);
            
            const size = centralness > 0.5 
              ? Math.random() * 2 + 1 
              : Math.random() * 1.5 + 0.5;
            
            this.particles.push({
              x: x,
              baseX: x,
              y: y,
              size: size,
              alpha: (0.3 + centralness * 0.5) * (Math.random() * 0.5 + 0.5),
              color: this.getParticleColor(),
              speed: 0.5 + Math.random() * 0.5,
              wobbleAmp: Math.random() * 20 + 5,
              wobbleFreq: Math.random() * 0.02 + 0.01,
              phase: Math.random() * Math.PI * 2
            });
          }
        }

        createAmbientParticles() {
          this.ambientParticles = [];
          const count = 800;
          
          for (let i = 0; i < count; i++) {
            // Spread across full width but avoid center
            let x = Math.random() * this.canvas.width;
            const distFromCenter = Math.abs(x - this.centerX);
            
            // Push particles toward edges if they're near center
            if (distFromCenter < 250) {
              x = x < this.centerX 
                ? Math.random() * (this.centerX - 300)
                : this.centerX + 300 + Math.random() * (this.canvas.width - this.centerX - 300);
            }
            
            this.ambientParticles.push({
              x: x,
              y: Math.random() * this.canvas.height,
              size: Math.random() * 2 + 0.5,
              alpha: Math.random() * 0.4 + 0.1,
              color: this.getParticleColor(),
              // Erratic movement
              vx: (Math.random() - 0.5) * 2,
              vy: (Math.random() - 0.5) * 2,
              targetVx: (Math.random() - 0.5) * 2,
              targetVy: (Math.random() - 0.5) * 2,
              changeTimer: Math.random() * 100,
              changeInterval: 50 + Math.random() * 100,
              // Twinkle
              twinkleSpeed: Math.random() * 0.05 + 0.02,
              twinklePhase: Math.random() * Math.PI * 2
            });
          }
        }

        gaussianRandom() {
          let u = 0, v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        }

        getNebulaColor() {
          const colors = [
            [180, 40, 220],
            [150, 30, 200],
            [200, 50, 180],
            [130, 40, 190],
            [170, 60, 210],
          ];
          return colors[Math.floor(Math.random() * colors.length)];
        }

        getParticleColor() {
          const colors = [
            [220, 180, 255],
            [255, 150, 220],
            [200, 160, 255],
            [255, 200, 240],
            [180, 140, 255],
          ];
          return colors[Math.floor(Math.random() * colors.length)];
        }

        update() {
          this.time += 0.016;
          
          // Update nebula layers
          this.nebulaLayers.forEach(layer => {
            layer.y += layer.speed;
            layer.x = this.centerX + (layer.baseY !== undefined ? 
              Math.sin(this.time * layer.wobbleFreq + layer.baseY * 0.01) * layer.wobbleAmp : 0);
            layer.rotation += layer.rotationSpeed;
            
            if (layer.y > this.canvas.height + layer.height) {
              layer.y = -layer.height;
              layer.baseY = layer.y;
            }
          });
          
          // Update central particles
          this.particles.forEach(p => {
            p.y += p.speed;
            p.x = p.baseX + Math.sin(this.time * p.wobbleFreq + p.phase) * p.wobbleAmp;
            
            if (p.y > this.canvas.height + 20) {
              p.y = -20;
              p.baseX = this.centerX + this.gaussianRandom() * 200;
            }
          });
          
          // Update ambient particles with erratic movement
          this.ambientParticles.forEach(p => {
            // Change direction randomly
            p.changeTimer++;
            if (p.changeTimer > p.changeInterval) {
              p.targetVx = (Math.random() - 0.5) * 3;
              p.targetVy = (Math.random() - 0.5) * 3;
              p.changeTimer = 0;
              p.changeInterval = 50 + Math.random() * 100;
            }
            
            // Smooth interpolation toward target velocity
            p.vx += (p.targetVx - p.vx) * 0.02;
            p.vy += (p.targetVy - p.vy) * 0.02;
            
            p.x += p.vx;
            p.y += p.vy;
            
            // Twinkle effect
            p.currentAlpha = p.alpha * (0.5 + 0.5 * Math.sin(this.time * p.twinkleSpeed + p.twinklePhase));
            
            // Wrap around screen
            if (p.x < -20) p.x = this.canvas.width + 20;
            if (p.x > this.canvas.width + 20) p.x = -20;
            if (p.y < -20) p.y = this.canvas.height + 20;
            if (p.y > this.canvas.height + 20) p.y = -20;
          });
        }

        render() {
          const ctx = this.ctx;
          
          ctx.fillStyle = '#030108';
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Ambient center glow
          const ambientGlow = ctx.createRadialGradient(
            this.centerX, this.canvas.height / 2, 0,
            this.centerX, this.canvas.height / 2, 400
          );
          ambientGlow.addColorStop(0, 'rgba(100, 30, 140, 0.15)');
          ambientGlow.addColorStop(0.5, 'rgba(60, 20, 100, 0.08)');
          ambientGlow.addColorStop(1, 'transparent');
          ctx.fillStyle = ambientGlow;
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Draw nebula layers
          ctx.globalCompositeOperation = 'screen';
          
          this.nebulaLayers.forEach(layer => {
            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.rotate(layer.rotation);
            
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, layer.width);
            gradient.addColorStop(0, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.alpha})`);
            gradient.addColorStop(0.4, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.alpha * 0.5})`);
            gradient.addColorStop(0.7, `rgba(${layer.color[0] * 0.7}, ${layer.color[1] * 0.7}, ${layer.color[2]}, ${layer.alpha * 0.2})`);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, layer.width, layer.height, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });
          
          // Draw particles with additive blend
          ctx.globalCompositeOperation = 'lighter';
          
          // Central nebula particles
          this.particles.forEach(p => {
            ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Ambient floating particles
          this.ambientParticles.forEach(p => {
            ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.currentAlpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
          });
          
          ctx.globalCompositeOperation = 'source-over';
        }

        animate() {
          this.update();
          this.render();
          requestAnimationFrame(() => this.animate());
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('bg-particles');
        if (canvas) new CosmicNebula(canvas);
      });
    </script>
  </body>
</html>
