---
// src/layouts/Layout.astro
import { supabase } from "../lib/supabase";
import ImpersonationBanner from "../components/ImpersonationBanner.astro";

interface Props {
  title?: string;
  description?: string;
}

const { title, description } = Astro.props;

let general = {
  siteName: "Banity",
  tagline: "Create Authentic Content. Get Paid.",
  description: "Banity connects creators with brands for authentic UGC campaigns.",
};

let appearance = {
  primaryColor: "#4f8bff",
  accentColor: "#a855f7",
  logoUrl: "",
  faviconUrl: "",
};

try {
  const { data } = await supabase.from("site_settings").select("key, value");
  if (data) {
    for (const row of data) {
      if (row.key === "general") general = { ...general, ...row.value };
      if (row.key === "appearance") appearance = { ...appearance, ...row.value };
    }
  }
} catch (e) {}

const pageTitle = title ? `${title} | ${general.siteName}` : `${general.siteName} - ${general.tagline}`;
const pageDescription = description || general.description;

const session = Astro.locals?.session;
const isAdmin = Astro.locals?.isAdmin;
const isModerator = Astro.locals?.isModerator;
const isImpersonating = Astro.locals?.isImpersonating || false;
const impersonatedUser = Astro.locals?.impersonatedUser;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{pageTitle}</title>
    <meta name="description" content={pageDescription} />
    {appearance.faviconUrl ? (
      <link rel="icon" href={appearance.faviconUrl} />
    ) : (
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    )}
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  </head>

  <body class:list={[{ "has-impersonation-banner": isImpersonating }]}>
    <canvas id="bg-particles" aria-hidden="true"></canvas>

    {isImpersonating && impersonatedUser && (
      <ImpersonationBanner user={impersonatedUser} />
    )}

    <nav class="main-nav">
      <div class="nav-content">
        <a href="/" class="nav-logo">
          {appearance.logoUrl ? (
            <img src={appearance.logoUrl} alt={general.siteName} class="logo-img" />
          ) : (
            <>
              <span class="logo-icon">✦</span>
              <span class="logo-text">{general.siteName}</span>
            </>
          )}
        </a>
        <div class="nav-links">
          <a href="/campaigns">Campaigns</a>
          <a href="/creators">Creators</a>
          <a href="/community">Community</a>
          <a href="/contact">Contact</a>
        </div>
        <div class="nav-actions">
          {session ? (
            <>
              <a href="/dashboard" class="nav-link">Dashboard</a>
              {(isAdmin || isModerator) && !isImpersonating && (
                <a href="/admin" class="nav-link">Admin</a>
              )}
              {!isImpersonating && <a href="/logout" class="nav-link">Log Out</a>}
            </>
          ) : (
            <>
              <a href="/login" class="nav-link">Sign In</a>
              <a href="/signup" class="nav-btn">Join Now</a>
            </>
          )}
        </div>
      </div>
    </nav>

    <main class="main-content">
      <slot />
    </main>

    <footer class="main-footer">
      <div class="footer-inner">
        <div class="footer-brand">
          <span class="footer-logo">✦ {general.siteName}</span>
          <p>The premier platform for UGC creators</p>
        </div>
        <div class="footer-links">
          <a href="/campaigns">Campaigns</a>
          <a href="/community">Community</a>
          <a href="/contact">Contact</a>
        </div>
        <div class="footer-copy">© 2024 {general.siteName}. All rights reserved.</div>
      </div>
    </footer>

    <style is:global>
      :root {
        --void: #030108;
        --nebula: #0a0510;
        --stardust: #150a20;
        --surface: #1a1025;
        --surface-light: #251535;
        --cosmic-blue: #8b5cf6;
        --cosmic-purple: #c026d3;
        --cosmic-pink: #ec4899;
        --cosmic-magenta: #d946ef;
        --cosmic-cyan: #a78bfa;
        --star-white: #f8fafc;
        --star-dim: #a78bfa;
        --star-muted: #7c3aed;
        --glow-purple: rgba(192, 38, 211, 0.5);
        --glow-pink: rgba(236, 72, 153, 0.5);
        --glow-violet: rgba(139, 92, 246, 0.5);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --font-display: 'Syne', system-ui, sans-serif;
        --font-mono: 'Space Mono', monospace;
      }

      * { margin: 0; padding: 0; box-sizing: border-box; }
      html { scroll-behavior: smooth; }

      body {
        font-family: var(--font-display);
        background: var(--void);
        color: var(--star-white);
        line-height: 1.6;
        min-height: 100vh;
        overflow-x: hidden;
      }

      a { color: inherit; }

      #bg-particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
      }

      .main-nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        padding: 1rem 2rem;
        background: linear-gradient(180deg, rgba(3, 1, 8, 0.95) 0%, rgba(3, 1, 8, 0.7) 50%, transparent 100%);
        backdrop-filter: blur(12px);
      }

      .nav-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 2rem;
      }

      .nav-logo {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        text-decoration: none;
        color: var(--star-white);
      }

      .logo-img { height: 32px; width: auto; }

      .logo-icon {
        font-size: 1.5rem;
        color: var(--cosmic-purple);
        text-shadow: 0 0 20px var(--glow-purple);
        animation: logo-glow 3s ease-in-out infinite;
      }

      @keyframes logo-glow {
        0%, 100% { text-shadow: 0 0 20px var(--glow-purple); }
        50% { text-shadow: 0 0 30px var(--glow-purple), 0 0 50px var(--glow-pink); }
      }

      .logo-text {
        font-size: 1.25rem;
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      .nav-links {
        display: flex;
        align-items: center;
        gap: 2rem;
      }

      .nav-links a {
        color: rgba(255, 255, 255, 0.6);
        text-decoration: none;
        font-size: 0.9375rem;
        font-weight: 500;
        transition: color 0.3s;
      }

      .nav-links a:hover { color: var(--star-white); }

      .nav-actions {
        display: flex;
        align-items: center;
        gap: 1.5rem;
      }

      .nav-link {
        color: rgba(255, 255, 255, 0.6);
        text-decoration: none;
        font-size: 0.9375rem;
        font-weight: 500;
        transition: color 0.3s;
      }

      .nav-link:hover { color: var(--star-white); }

      .nav-btn {
        padding: 0.625rem 1.5rem;
        background: linear-gradient(135deg, var(--cosmic-purple), var(--cosmic-pink));
        border-radius: 100px;
        color: white !important;
        text-decoration: none;
        font-weight: 600;
        font-size: 0.875rem;
        transition: all 0.3s;
        box-shadow: 0 4px 20px rgba(192, 38, 211, 0.3);
      }

      .nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 30px rgba(192, 38, 211, 0.5);
      }

      .main-content {
        position: relative;
        z-index: 1;
        min-height: calc(100vh - 200px);
        padding-top: 80px;
      }

      .main-footer {
        position: relative;
        z-index: 1;
        padding: 3rem 2rem;
        border-top: 1px solid rgba(192, 38, 211, 0.1);
        background: linear-gradient(180deg, transparent, rgba(3, 1, 8, 0.9));
      }

      .footer-inner {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 2rem;
      }

      .footer-logo {
        font-size: 1.125rem;
        font-weight: 700;
        color: var(--star-white);
      }

      .footer-brand p {
        margin-top: 0.5rem;
        font-size: 0.875rem;
        color: rgba(255, 255, 255, 0.5);
      }

      .footer-links {
        display: flex;
        gap: 2rem;
      }

      .footer-links a {
        color: rgba(255, 255, 255, 0.5);
        text-decoration: none;
        font-size: 0.875rem;
        transition: color 0.3s;
      }

      .footer-links a:hover { color: var(--star-white); }

      .footer-copy {
        width: 100%;
        text-align: center;
        padding-top: 2rem;
        border-top: 1px solid rgba(192, 38, 211, 0.1);
        font-size: 0.8125rem;
        color: rgba(255, 255, 255, 0.4);
      }

      /* Global utility classes */
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1.5rem;
        border-radius: 12px;
        font-weight: 600;
        font-size: 0.9375rem;
        text-decoration: none;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
      }

      .btn-primary {
        background: linear-gradient(135deg, var(--cosmic-purple), var(--cosmic-pink));
        color: white;
        box-shadow: 0 4px 20px rgba(192, 38, 211, 0.3);
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 30px rgba(192, 38, 211, 0.5);
      }

      .btn-secondary {
        background: rgba(192, 38, 211, 0.15);
        color: var(--star-white);
        border: 1px solid rgba(192, 38, 211, 0.3);
      }

      .btn-secondary:hover {
        background: rgba(192, 38, 211, 0.25);
        border-color: var(--cosmic-purple);
      }

      .btn-disabled {
        background: var(--surface);
        color: var(--star-muted);
        cursor: not-allowed;
      }

      @media (max-width: 768px) {
        .nav-links { display: none; }
        .nav-actions { gap: 1rem; }
        .footer-inner { flex-direction: column; text-align: center; }
        .footer-links { justify-content: center; }
      }
    </style>

    <script is:inline>
      class FlowingNebula {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.particles = [];
          this.tendrils = [];
          this.time = 0;
          this.noiseScale = 0.003;
          this.flowStrength = 2;
          this.verticalSpeed = 1.2;
          
          // Noise permutation table
          this.perm = [];
          for (let i = 0; i < 512; i++) {
            this.perm[i] = Math.floor(Math.random() * 256);
          }
          
          this.init();
          this.animate();
        }

        init() {
          this.resize();
          this.createParticles();
          this.createTendrils();
          
          window.addEventListener('resize', () => {
            this.resize();
            this.createParticles();
            this.createTendrils();
          });
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        // Simplex-like noise
        noise(x, y, z) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;
          
          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);
          
          const u = x * x * (3 - 2 * x);
          const v = y * y * (3 - 2 * y);
          const w = z * z * (3 - 2 * z);
          
          const A = this.perm[X] + Y;
          const AA = this.perm[A] + Z;
          const AB = this.perm[A + 1] + Z;
          const B = this.perm[X + 1] + Y;
          const BA = this.perm[B] + Z;
          const BB = this.perm[B + 1] + Z;
          
          const lerp = (t, a, b) => a + t * (b - a);
          const grad = (hash, x, y, z) => {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
          };
          
          return lerp(w,
            lerp(v,
              lerp(u, grad(this.perm[AA], x, y, z), grad(this.perm[BA], x - 1, y, z)),
              lerp(u, grad(this.perm[AB], x, y - 1, z), grad(this.perm[BB], x - 1, y - 1, z))
            ),
            lerp(v,
              lerp(u, grad(this.perm[AA + 1], x, y, z - 1), grad(this.perm[BA + 1], x - 1, y, z - 1)),
              lerp(u, grad(this.perm[AB + 1], x, y - 1, z - 1), grad(this.perm[BB + 1], x - 1, y - 1, z - 1))
            )
          );
        }

        createParticles() {
          this.particles = [];
          const count = 20000;
          
          for (let i = 0; i < count; i++) {
            const x = Math.random() * this.canvas.width;
            const y = Math.random() * this.canvas.height;
            
            // Cluster particles toward center streams
            const streamCount = 5;
            const streamWidth = this.canvas.width / streamCount;
            const nearestStream = Math.round(x / streamWidth) * streamWidth;
            const distToStream = Math.abs(x - nearestStream);
            const inStream = distToStream < streamWidth * 0.4;
            
            const layer = Math.random();
            let size, brightness;
            
            if (layer < 0.5) {
              size = Math.random() * 1 + 0.3;
              brightness = Math.random() * 0.4 + 0.1;
            } else if (layer < 0.85) {
              size = Math.random() * 1.5 + 0.5;
              brightness = Math.random() * 0.6 + 0.2;
            } else {
              size = Math.random() * 2.5 + 1;
              brightness = Math.random() * 0.8 + 0.4;
            }
            
            if (inStream) {
              size *= 1.3;
              brightness *= 1.2;
            }
            
            this.particles.push({
              x: x,
              y: y,
              size: size,
              baseSize: size,
              brightness: Math.min(brightness, 1),
              baseBrightness: Math.min(brightness, 1),
              color: this.getColor(x / this.canvas.width),
              vx: 0,
              vy: 0,
              life: Math.random(),
              pulsePhase: Math.random() * Math.PI * 2,
              pulseSpeed: Math.random() * 0.02 + 0.005
            });
          }
        }

        createTendrils() {
          this.tendrils = [];
          const tendrilCount = 80;
          
          for (let i = 0; i < tendrilCount; i++) {
            const points = [];
            let x = Math.random() * this.canvas.width;
            let y = -Math.random() * 500;
            
            const length = Math.floor(Math.random() * 150 + 100);
            
            for (let j = 0; j < length; j++) {
              points.push({ x, y });
              
              const noiseVal = this.noise(x * 0.002, y * 0.002, i * 0.1);
              x += Math.sin(noiseVal * Math.PI * 2) * 3;
              y += 5;
            }
            
            this.tendrils.push({
              points: points,
              width: Math.random() * 40 + 20,
              color: this.getColor(x / this.canvas.width),
              opacity: Math.random() * 0.15 + 0.05,
              speed: Math.random() * 0.8 + 0.4,
              offset: 0
            });
          }
        }

        getColor(position) {
          const colors = [
            { r: 120, g: 20, b: 180 },   // Deep purple
            { r: 180, g: 30, b: 200 },   // Magenta
            { r: 220, g: 50, b: 160 },   // Pink
            { r: 140, g: 40, b: 220 },   // Violet
            { r: 200, g: 60, b: 180 },   // Bright magenta
            { r: 100, g: 30, b: 160 }    // Dark purple
          ];
          
          const idx = Math.floor(position * colors.length) % colors.length;
          const nextIdx = (idx + 1) % colors.length;
          const t = (position * colors.length) % 1;
          
          return {
            r: colors[idx].r + (colors[nextIdx].r - colors[idx].r) * t,
            g: colors[idx].g + (colors[nextIdx].g - colors[idx].g) * t,
            b: colors[idx].b + (colors[nextIdx].b - colors[idx].b) * t
          };
        }

        update() {
          this.time += 0.008;
          
          // Update tendrils
          this.tendrils.forEach(tendril => {
            tendril.offset += tendril.speed * this.verticalSpeed;
            
            if (tendril.offset > this.canvas.height + 500) {
              tendril.offset = -tendril.points.length * 5;
              tendril.points.forEach((p, i) => {
                p.x = Math.random() * this.canvas.width;
              });
            }
          });
          
          // Update particles with flow field
          this.particles.forEach(p => {
            const noiseX = this.noise(p.x * this.noiseScale, p.y * this.noiseScale, this.time);
            const noiseY = this.noise(p.x * this.noiseScale + 100, p.y * this.noiseScale + 100, this.time);
            
            const angle = noiseX * Math.PI * 2;
            
            p.vx = Math.cos(angle) * this.flowStrength * 0.5;
            p.vy = this.verticalSpeed + noiseY * 0.5;
            
            p.x += p.vx;
            p.y += p.vy;
            
            // Pulse
            const pulse = Math.sin(this.time * 3 + p.pulsePhase);
            p.size = p.baseSize * (0.7 + 0.3 * pulse);
            p.brightness = p.baseBrightness * (0.6 + 0.4 * pulse);
            
            // Wrap
            if (p.y > this.canvas.height + 20) {
              p.y = -20;
              p.x = Math.random() * this.canvas.width;
              p.color = this.getColor(p.x / this.canvas.width);
            }
            if (p.x < -50) p.x = this.canvas.width + 50;
            if (p.x > this.canvas.width + 50) p.x = -50;
          });
        }

        render() {
          // Dark background with subtle purple tint
          this.ctx.fillStyle = '#030108';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Background glow
          const centerGlow = this.ctx.createRadialGradient(
            this.canvas.width / 2, this.canvas.height / 2, 0,
            this.canvas.width / 2, this.canvas.height / 2, this.canvas.width * 0.6
          );
          centerGlow.addColorStop(0, 'rgba(80, 20, 100, 0.15)');
          centerGlow.addColorStop(0.5, 'rgba(50, 10, 70, 0.08)');
          centerGlow.addColorStop(1, 'transparent');
          this.ctx.fillStyle = centerGlow;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Draw tendrils (flowing smoke/gas)
          this.ctx.globalCompositeOperation = 'screen';
          
          this.tendrils.forEach(tendril => {
            this.ctx.beginPath();
            
            const offsetY = tendril.offset;
            
            for (let i = 0; i < tendril.points.length; i++) {
              const p = tendril.points[i];
              const y = p.y + offsetY;
              
              if (y < -100 || y > this.canvas.height + 100) continue;
              
              const noiseOffset = this.noise(p.x * 0.005, y * 0.005, this.time + i * 0.01) * 30;
              const x = p.x + noiseOffset;
              
              if (i === 0) {
                this.ctx.moveTo(x, y);
              } else {
                this.ctx.lineTo(x, y);
              }
            }
            
            const gradient = this.ctx.createLinearGradient(0, offsetY, 0, offsetY + tendril.points.length * 5);
            gradient.addColorStop(0, `rgba(${tendril.color.r}, ${tendril.color.g}, ${tendril.color.b}, 0)`);
            gradient.addColorStop(0.2, `rgba(${tendril.color.r}, ${tendril.color.g}, ${tendril.color.b}, ${tendril.opacity})`);
            gradient.addColorStop(0.8, `rgba(${tendril.color.r}, ${tendril.color.g}, ${tendril.color.b}, ${tendril.opacity})`);
            gradient.addColorStop(1, `rgba(${tendril.color.r}, ${tendril.color.g}, ${tendril.color.b}, 0)`);
            
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = tendril.width;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.filter = `blur(${tendril.width / 3}px)`;
            this.ctx.stroke();
            this.ctx.filter = 'none';
          });
          
          // Draw particles
          this.ctx.globalCompositeOperation = 'lighter';
          
          this.particles.forEach(p => {
            // Glow for larger particles
            if (p.size > 1) {
              const glowSize = p.size * 4;
              const glow = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);
              glow.addColorStop(0, `rgba(${p.color.r + 50}, ${p.color.g + 30}, ${p.color.b + 30}, ${p.brightness * 0.5})`);
              glow.addColorStop(0.4, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.brightness * 0.2})`);
              glow.addColorStop(1, 'transparent');
              
              this.ctx.fillStyle = glow;
              this.ctx.beginPath();
              this.ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
              this.ctx.fill();
            }
            
            // Core particle
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(${p.color.r + 80}, ${p.color.g + 60}, ${p.color.b + 60}, ${p.brightness})`;
            this.ctx.fill();
          });
          
          this.ctx.globalCompositeOperation = 'source-over';
        }

        animate() {
          this.update();
          this.render();
          requestAnimationFrame(() => this.animate());
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('bg-particles');
        if (canvas) new FlowingNebula(canvas);
      });
    </script>
  </body>
</html>
